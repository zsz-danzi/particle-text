<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html, body, #cvs {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            position: relative;
        }
        .none {
            display: none;
        }
        .button {
            width: 120px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            display: block;
            background-color: #fff;
            border:1px solid #000;  
            color: #000;
            text-decoration: none;
            font-size: 14px;
            position: absolute;
            top: 0;
            right: 0;
            z-index: 10;
        }
    </style>
</head>
<body>

    <!-- <img id="tulip" src="img.png" alt="The Tulip" class="none" /> -->
    <a class="button" id="btn" href="javascript:;">散开</a>
    <canvas id="cvs"></canvas>
	
	<!-- <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script> -->
	<script src="webgl-utils.js"></script>
	
	<!-- vertex shader -->
	<script  id="vertex-shader-2d" type="x-shader/x-vertex">
		attribute vec2 a_position;
		attribute vec2 a_texCoord;
		
		uniform vec2 u_resolution;
		
		varying vec2 v_texCoord;
		
		void main() {
			 // convert the rectangle from pixels to 0.0 to 1.0
			 vec2 zeroToOne = a_position / u_resolution;
		
			 // convert from 0->1 to 0->2
			 vec2 zeroToTwo = zeroToOne * 2.0;
		
			 // convert from 0->2 to -1->+1 (clipspace)
			 vec2 clipSpace = zeroToTwo - 1.0;
		
			 gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
		
			 // pass the texCoord to the fragment shader
			 // The GPU will interpolate this value between points.
			 v_texCoord = a_texCoord;
		}
		</script>

		<!-- fragment shader -->
		<script  id="fragment-shader-2d" type="x-shader/x-fragment">
		precision mediump float;
		
		// our texture
		uniform sampler2D u_image;
		
		// the texCoords passed in from the vertex shader.
		varying vec2 v_texCoord;
		
		void main() {
			 gl_FragColor = texture2D(u_image, v_texCoord);
		}
		</script>
	<script>

		function main() {
			var image = new Image();
			image.src = "https://webglfundamentals.org/webgl/resources/leaves.jpg";  // MUST BE SAME DOMAIN!!!
			image.crossOrigin = "anonymous";
			image.onload = function() {
				render(image);
			};
		}

		function render(image) {
			// Get A WebGL context
			/** @type {HTMLCanvasElement} */
			var canvas = document.querySelector("#cvs");
			var gl = canvas.getContext("webgl");

			// console.log(gl.canvas)

			let x1 = 0;
			let currentPosition = [0, 0];

			if (!gl) {
				return;
			}

			function drawImage() {
				
			}

			// setup GLSL program
			var program = webglUtils.createProgramFromScripts(gl, ["vertex-shader-2d", "fragment-shader-2d"]);

			// look up where the vertex data needs to go. 查找顶点数据需要去的地方
			var positionLocation = gl.getAttribLocation(program, "a_position");
			var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

			// Create a buffer to put three 2d clip space points in
			var positionBuffer = gl.createBuffer();

			// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			// Set a rectangle the same size as the image.

			// 
			setRectangle(gl, x1, 0, image.width, image.height);
		
			// provide texture coordinates for the rectangle.
			var texcoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
					0.0,  0.0,
					1.0,  0.0,
					0.0,  1.0,
					0.0,  1.0,
					1.0,  0.0,
					1.0,  1.0,
			]), gl.STATIC_DRAW);

			// Create a texture.
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);

			// Set the parameters so we can render any size image.
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			// Upload the image into the texture.
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

			// lookup uniforms
			var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
				webglUtils.resizeCanvasToDisplaySize(gl.canvas, 2);


			// 动画假设
			animate();
			function animate() {
				// Tell WebGL how to convert from clip space to pixels
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);


				// Clear the canvas
				gl.clearColor(0, 0, 0, 0);
				gl.clear(gl.COLOR_BUFFER_BIT);

				// 渲染
				// Tell it to use our program (pair of shaders)
				gl.useProgram(program);

				// Turn on the position attribute
				gl.enableVertexAttribArray(positionLocation);

				// Bind the position buffer.
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

				// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
				var size = 2;          // 2 components per iteration
				var type = gl.FLOAT;   // the data is 32bit floats
				var normalize = false; // don't normalize the data
				var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
				var offset = 0;        // start at the beginning of the buffer
				gl.vertexAttribPointer(
						positionLocation, size, type, normalize, stride, offset);

				// Turn on the texcoord attribute
				gl.enableVertexAttribArray(texcoordLocation);

				// bind the texcoord buffer.
				gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

				// Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)
				var size = 2;          // 2 components per iteration
				var type = gl.FLOAT;   // the data is 32bit floats
				var normalize = false; // don't normalize the data
				var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
				var offset = 0;        // start at the beginning of the buffer
				gl.vertexAttribPointer(
						texcoordLocation, size, type, normalize, stride, offset);

						x1+=100;
				currentPosition[0] = x1 + 10;

				// console.log(currentPosition[0])

				gl.uniform2fv(resolutionLocation, currentPosition);

				// resolutionLocation.x = 100;
				// console.log(resolutionLocation)				
				gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);


				// 
				// setRectangle(gl, x1, 0, image.width, image.height);

				// Draw the rectangle.
				var primitiveType = gl.TRIANGLES;
				var offset = 0;
				var count = 6;
				gl.drawArrays(primitiveType, offset, count);

				requestAnimationFrame(animate);
			}


		}

		function setRectangle(gl, x, y, width, height) {
			var x1 = x;
			var x2 = x + width;
			var y1 = y;
			var y2 = y + height;
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
				x1, y1,
				x2, y1,
				x1, y2,
				x1, y2,
				x2, y1,
				x2, y2,
			]), gl.STATIC_DRAW);
		}
	
		main();


	</script>

</body>
</html>